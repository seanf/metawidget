<?xml version="1.0" encoding="UTF-8"?>
	<chapter id="chapter-inspectors">
		<title>Inspectors</title>
		
		<para>
			This chapter covers each <classname>Inspector</classname> in detail. For an explanation of how
			<classname>Inspector</classname>s
			fit into the overall architecture of Metawidget, see <xref linkend="chapter-architecture"/>
		</para>

		<para>
			Throughout this chapter when we say 'returns the following attributes' this is a shorthand way
			of saying 'returns the following Metawidget attributes (via a piece of XML conforming to <filename>inspection-result.xsd</filename>).
			These are passed to the <classname>WidgetBuilder</classname> to assist with choosing appropriate widgets'. Quite
			which widget will be chosen is covered in <xref linkend="chapter-widgetbuilders"/>: it could be
			a JSF <classname>HtmlInputTextarea</classname>, or a Swing <classname>JTextArea</classname>, or some
			other widget from some other framework.
		</para>

		<section id="section-inspectors-composite">
			<title>Composite Inspector</title>
			
			<para>
				<classname>CompositeInspector</classname>
				(the name refers to the Composite design pattern)
				delegates inspection to one or more sub-inspectors, then combines the resulting DOMs.
				The combining algorithm works as follows. For each element:
			</para>
			
			<orderedlist>
				<listitem>
					<para>
						top-level elements (typically <parameter>entity</parameter>)
						with the same <parameter>type</parameter> attribute in both DOMs are combined
					</para>
				</listitem>
				<listitem>
					<para>
						child elements (typically <parameter>property</parameter> or <parameter>action</parameter>)
						with the same <parameter>name</parameter> attribute in both DOMs are combined
					</para>
				</listitem>
				<listitem>
					<para>
						the ordering of child elements (typically <parameter>property</parameter> or <parameter>action</parameter>)
						in the existing DOM is preserved. New child elements are
						added either at the end or immediately after the last combined child
					</para>
				</listitem>
				<listitem>
					<para>
						element attributes from the new DOM override ones in the existing DOM (e.g. <parameter>hidden</parameter>
						or <parameter>read-only</parameter>)					
					</para>
				</listitem>				
			</orderedlist>

			<para>
				This algorithm should be suitable for most use cases, but one benefit of having a separate
				<classname>CompositeInspector</classname> is that developers can replace it with their own version, with its own
				combining algorithm, if required.
			</para>

		</section>

		<section id="section-inspectors-property">
			<title>Property Inspectors</title>

			<para>
				Being an OIM, a core strength of Metawidget is inspecting Objects. Metawidget is very flexible in this regard, with
				pluggable support for different languages and different implementation styles.
			</para>
			
			<section id="section-inspectors-base-object">
				<title>BaseObjectInspector</title>
				
				<para>
					<classname>BaseObjectInspector</classname> underlies many of the <classname>Inspector</classname>s that inspect objects (as opposed to, say,
					XML files). It provides easy-to-override methods such as...
				</para>
				
				<programlisting language="java">protected Map&lt;String, String&gt; inspectProperty( Property property )</programlisting>
				
				<para>
					...for inspecting properties, and...
				</para>

				<programlisting language="java">protected Map&lt;String, String&gt; inspectAction( Action action )</programlisting>
				
				<para>
					...for inspecting actions, and finally...
				</para>

				<programlisting language="java">protected Map&lt;String, String&gt; inspectTrait( Trait trait )</programlisting>
				
				<para>
					...for inspecting things that apply to both properties and actions (e.g. <classname>@UiLabel</classname>). Quite what
					constitutes a 'property' or an 'action' is decoupled into pluggable <classname>PropertyStyle</classname>s
					and <classname>ActionStyle</classname>s.
				</para>
				
				<section id="section-inspectors-base-object-propertystyle">
					<title>PropertyStyle</title>
					
					<para>
						The <classname>PropertyStyle</classname> interface allows pluggable, fine-grained control over what is considered a 'property'.					
						Different environments may have different approaches to defining what constitutes a property. For
						example, JavaBean-properties are convention-based, whereas Groovy has explicit property support.
 						Equally, some environments may have framework-specific, base class properties that should be filtered out
 						and excluded from the list of 'real' business model properties.					
					</para>
					
					<para>
						The default <classname>PropertyStyle</classname> is <classname>JavaBeanPropertyStyle</classname>. To change it
						within <filename>metawidget.xml</filename>:
					</para>
					
					<programlisting language="xml">&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"
	config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;propertyStyle&gt;
		&lt;groovyPropertyStyle xmlns="java:org.metawidget.inspector.impl.propertystyle.groovy"/&gt;
	&lt;/propertyStyle&gt;
&lt;/propertyTypeInspector&gt;</programlisting>
					
					<para>
						To change it programmatically:
					</para>
					
					<programlisting language="java">BaseObjectInspectorConfig config = new BaseObjectInspectorConfig();
config.setPropertyStyle( new GroovyPropertyStyle() );
metawidget.setInspector( new PropertyTypeInspector( config ) );</programlisting>

					<section id="section-inspectors-base-object-propertystyle-javabean">
						<title>JavaBeanPropertyStyle</title>
					
						<para>
							The <classname>JavaBeanPropertyStyle</classname> is the default <classname>PropertyStyle</classname> used
							by all <classname>BaseObjectInspector</classname> subclasses (which includes all annotation inspectors).
						</para>
						
						<para>
							This <classname>PropertyStyle</classname> recognizes JavaBean-convention <function>getXXX</function>,
							<function>setXXX</function> and <function>isXXX</function>
							methods. In addition, it maintains a cache of reflected classes for performance. 
						</para>

						<para>
							When using getter methods with private members, make sure you annotate the getter/setter <emphasis>not the private
							field</emphasis>. By default, <classname>JavaBeanPropertyStyle</classname> does not find annotations on private fields, because
							the JavaBean specification does not define a way to determine which private fields belong to which getter/setter methods.
							However, many developers adopt a naming convention (e.g. getter <function>isFoo</function> maps to field <function>mFoo</function>) and
							you can specify your preferred convention using <function>JavaBeanPropertyStyleConfig.setPrivateFieldConvention</function>. This
							method takes a <classname>MessageFormat</classname> parameter which you can use to format the property name accordingly.
							For example:
						</para>
						
						<informaltable>
							<colgroup>
								<col width="40%"/>
								<col width="60%"/>
							</colgroup>
							<thead>
								<tr>
									<th align="left">Format</th>
									<th align="left">Private Field Name</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>{0}</td>
									<td>dateOfBirth, surname</td>
								</tr>
								<tr>
									<td>'m'{1}</td>
									<td>mDateOfBirth, mSurname</td>
								</tr>
								<tr>
									<td>'m_'{0}</td>
									<td>m_dateOfBirth, m_surname</td>
								</tr>
							</tbody>
						</informaltable>
						
						<para>
							If you need more control over the mapping, consider extending <classname>JavaBeanPropertyStyle</classname> and
							overriding <function>getPrivateField</function>. You could also use
							<function>JavaBeanPropertyStyleConfig.setSupportPublicFields( true )</function> to recognize
							public fields directly, though this is not recommended.  
						</para>						
						
					</section>
					
					<section id="section-inspectors-base-object-propertystyle-groovy">
						<title>GroovyPropertyStyle</title>
					
						<para>
							The <classname>GroovyPropertyStyle</classname> recognizes GroovyBean properties.
						</para>
						
						<para>
							Groovy tries hard to make its GroovyBean properties compatible with JavaBean getters/setters, and indeed
							one can almost use the default <classname>JavaBeanPropertyStyle</classname> to read them. Unfortunately, GroovyBeans
							differ in that:
						</para>
						
						<itemizedlist>
							<listitem>
								<para>
									annotations defined on properties are only attached to the (generated) private member
									variable, not the (generated) getter/setter methods.
								</para>
							</listitem>
							<listitem>
								<para>
									GroovyBeans define an implicit <function>getMetaClass</function> method which, although matching
									the JavaBean signature, should not be treated as a business model property.
								</para>
							</listitem>
						</itemizedlist>
	
					</section>
					
					<section id="section-inspectors-base-object-propertystyle-javassist">
						<title>JavassistPropertyStyle</title>
							
						<para>
							The <classname>JavassistPropertyStyle</classname> extends
							<classname>JavaBeanPropertyStyle</classname> and makes use of Javassist for those environments
							that have it available.
						</para>
						
						<para>
							Javassist is used to inspect the debug line numbering information embedded in JVM bytecode
							to sort getters/setters according to their original declaration order in the source code. This saves domain objects
							having to use <classname>@UiComesAfter</classname> (or an XML file, or some other method) to impose an ordering.
						</para>
						
						<para>
							However, a danger of this approach is that if the domain objects are ever recompiled <emphasis>without</emphasis> debug
							line numbering information (e.g. when moving from development to production) the UI fields will lose their
							ordering. Such a subtle bug may not be picked up, so as a safeguard <classname>JavassistPropertyStyle</classname>
							'fails hard' with an <classname>InspectorException</classname> if line numbers are not available.
						</para>
						
						<para>
							<classname>JavassistPropertyStyle</classname> uses the following sorting algorithm:
						</para>
						
						<itemizedlist>
							<listitem>
								<para>
									superclass public fields come first, sorted by name (if
									<function>JavaBeanPropertyStyleConfig.setSupportPublicFields</function> has been set).
								</para>
							</listitem>
							<listitem>
								<para>
									superclass methods come next, sorted by getter line number (or, if no getter, setter line number).
								</para>
							</listitem>
							<listitem>
								<para>
									public fields come next, sorted by name (if
									<function>JavaBeanPropertyStyleConfig.setSupportPublicFields</function> has been set).
								</para>
							</listitem>
							<listitem>
								<para>
									methods come last, sorted by getter line number (or, if no getter, setter line number).
								</para>
							</listitem>
						</itemizedlist>
						
						<para>
							Note this algorithm is less flexible than <classname>@UiComesAfter</classname>, which can
							interleave superclass and subclass properties. However, it is possible to use both
							<classname>@UiComesAfter</classname> and <classname>JavassistPropertyStyle</classname> together to get the best of
							both worlds.						
						</para>
							
					</section>
	
					<section id="section-inspectors-base-object-propertystyle-scala">
						<title>ScalaPropertyStyle</title>
					
						<para>
							The <classname>ScalaPropertyStyle</classname> recognizes Scala properties.
						</para>
						
						<para>
							Scala <emphasis>can</emphasis> make its properties compatible with JavaBean getters/setters, but only if you
							put special <classname>@BeanProperty</classname> annotations on them. This can be quite onerous.
							Instead, <classname>ScalaPropertyStyle</classname> is designed to access Scala properties natively.
						</para>
						
					</section>
	
					<section id="section-inspectors-base-object-propertystyle-implementing-your-own">
						<title>Implementing Your Own PropertyStyle</title>
						<para>
							All <classname>PropertyStyle</classname>s must implement the <classname>PropertyStyle</classname> interface. <classname>BasePropertyStyle</classname>
							assists in caching properties per class (looking them up is often expensive, involving reflection or similar
							techniques) and in excluding properties based on name, type or base class. Here
							is an example of a custom <classname>PropertyStyle</classname> that identifies properties based
							on <classname>ResourceBundle</classname> i18n entries. It extends the code from the tutorial
							(see <xref linkend="section-introduction-java-part1"/>).
						</para>
					
						<programlisting language="java">package com.myapp;
				
<symbol>import java.util.*;</symbol>
import javax.swing.*;
<symbol>import org.metawidget.inspector.iface.*;
import org.metawidget.inspector.impl.*;
import org.metawidget.inspector.impl.propertystyle.*;
import org.metawidget.inspector.impl.propertystyle.javabean.*;
import org.metawidget.inspector.propertytype.*;</symbol>
import org.metawidget.swing.*;
<symbol>import org.metawidget.util.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>metawidget.setInspector( new PropertyTypeInspector( new BaseObjectInspectorConfig()
			.setPropertyStyle( new BundlePropertyStyle() ) ) );</symbol>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
	
	<symbol>static class BundlePropertyStyle
		extends JavaBeanPropertyStyle {

		protected Map&lt;String, Property&gt; inspectProperties( String type ) {
			try {
				Class&lt;?&gt; clazz = ClassUtils.niceForName( type );
				Map&lt;String, Property&gt; properties = CollectionUtils.newTreeMap();
				ResourceBundle bundle = ResourceBundle.getBundle( "MyBundle" );

				for ( Enumeration&lt;String&gt; e = bundle.getKeys(); e.hasMoreElements(); ) {
					String key = e.nextElement();
					properties.put( key, new FieldProperty( key, clazz.getField( key ) ) );
				}

				return properties;
			}
			catch ( Exception ex ) {
				throw InspectorException.newException( ex );
			}
		}
	}</symbol>
}</programlisting>
					
						<para>
							For brevity, this example extends <classname>JavaBeanPropertyStyle</classname>. Normally, you would
							want to extend <classname>BasePropertyStyle</classname> and, as well as overriding <function>inspectProperties</function>
							to locate the properties, implement the <classname>Property</classname> interface with mechanisms
							for interrogating the property.
						</para>
						
						<tip>
							<title>Note</title>
							In this particular example, it may be useful to create a <classname>BundlePropertyStyleConfig</classname> class that
							implements <classname>NeedsResourceResolver</classname> (see <xref linkend="section-architecture-xml-resolving-resources"/>).
							Then it could use <classname>ResourceResolver.openResource</classname> to locate the bundle in case it
							was in a specialized location (such as <filename>WEB-INF/</filename>).
						</tip>
						
					</section>
				</section>
				
				<section id="section-inspectors-base-object-actionstyle">
					<title>ActionStyle</title>
					
					<para>
						The <classname>ActionStyle</classname> interface allows pluggable, fine-grained control over what is considered an 'action'.					
					</para>
					
					<para>
						Different environments may have different approaches to defining what constitutes an action. For
						example, the Swing AppFramework uses an <classname>@org.jdesktop.application.Action</classname> annotation.
					</para>
					
					<para>
						The default <classname>ActionStyle</classname> is <classname>MetawidgetActionStyle</classname>. To change it within <filename>metawidget.xml</filename>:
					</para>
					
				<programlisting language="xml">&lt;metawidgetAnnotationInspector config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;actionStyle&gt;
		&lt;swingAppFrameworkActionStyle xmlns="java:org.metawidget.inspector.impl.actionstyle.swing"&gt;
	&lt;/actionStyle&gt;
&lt;/metawidgetAnnotationInspector&gt;</programlisting>
					
					<para>
						To change it programmatically:
					</para>
					
					<programlisting language="java">BaseObjectInspectorConfig config = new BaseObjectInspectorConfig();
config.setActionStyle( SwingAppFrameworkActionStyle.class );
metawidget.setInspector( new MetawidgetAnnotationInspector( config ) );</programlisting>

					<para>
						Note these <classname>ActionStyle</classname>s only apply to <classname>BaseObjectInspector</classname> and its subclasses. This covers
						most annotation-recognising <classname>Inspector</classname>s (e.g. <classname>JpaInspector</classname>, <classname>HibernateValidatorInspector</classname>)
						but <emphasis>not</emphasis> XML-based inspectors. For example, <classname>PageflowInspector</classname> recognizes actions in
						JBoss jBPM pageflow XML files without using any <classname>ActionStyle</classname>.
					</para>
					
					<section id="section-inspectors-base-object-metawidget">
						<title>MetawidgetActionStyle</title>
					
						<para>
							The default Metawidget <classname>ActionStyle</classname> recognizes any method annotated with <classname>@UiAction</classname>. Action methods
							must not accept any parameters in their signature. 
						</para>
						
					</section>
					
					<section id="section-inspectors-base-object-appframework">
						<title>SwingAppFrameworkActionStyle</title>
					
						<para>
							The <classname>SwingAppFrameworkActionStyle</classname> recognises Swing AppFramework's <classname>@Action</classname>
							annotation as denoting an action.
						</para>
	
					</section>
				</section>

			</section>
			
			<section id="section-inspectors-java-propertytype">
				<title>PropertyTypeInspector (Java version)</title>
				
				<para>
					<classname>PropertyTypeInspector</classname> extends <classname>BaseObjectInspector</classname>, and so inherits its features.
					In addition, it returns the following attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Property Type</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>lookup</parameter></td>
							<td>
								lookup of 'true, false' if the type is Boolean.
								Values of enums, as returned by .name(), if the type is Enum
							</td>
						</tr>
						<tr>
							<td><parameter>lookup-labels</parameter></td>
							<td>
								lookup of 'Yes, No' if the type is Boolean. This will generally
								be localized by the Metawidget. Labels of enums, as returned by
								.toString(), if the type is Enum
							</td>
						</tr>
						<tr>
							<td><parameter>no-setter</parameter></td>
							<td>
								if the property has no <function>setXXX</function> method. Note <parameter>no-setter</parameter>
								is distinct from <parameter>read-only</parameter>, because it is common to
								have no setter for a complex type (e.g. <function>Person.getAddress</function>) but
								this shouldn't make all its contents (e.g. <function>Address.getStreet</function>) read-only.
							</td>
						</tr>
						<tr>
							<td><parameter>no-getter</parameter></td>
							<td>
								if the property has no <function>getXXX</function> method
							</td>
						</tr>
						<tr>
							<td><parameter>parameterized-type</parameter></td>
							<td>
								if the property is using generics
							</td>
						</tr>
						<tr>
							<td><parameter>type</parameter></td>
							<td>declared type of the property</td>
						</tr>
						<tr>
							<td><parameter>actual-type</parameter></td>
							<td>
								if the actual type differs from the declared type (i.e. it is a subclass)
							</td>
						</tr>
					</tbody>
				</informaltable>

			</section>
			
			<section id="section-inspectors-java-jsonschema">
				<title>JsonSchemaInspector (Java version)</title>
				
				<para>
					Inspector to look for metadata in JSON Schema files. Consider using in conjunction with
 					<classname>JsonSchemaTypeMappingProcessorConfig</classname> to convert JSON types into Java types.
				</para>
				
				<programlisting language="java">public static void main( String[] args ) {

	// Metawidget

	Display display = new Display();
	Shell shell = new Shell( display );
	shell.setText( "JSON Viewer" );
	shell.setLayout( new FillLayout() );

	String jsonSchema = "{ properties: { \"firstname\": { \"type\": \"string\", \"required\": true }, ";
	jsonSchema += "\"age\": { \"type\": \"number\" }, ";
	jsonSchema += "\"notes\": { \"type\": \"string\", \"large\": true }}}";

	final SwtMetawidget metawidget = new SwtMetawidget( shell, SWT.None );
	metawidget.setInspector( new JsonSchemaInspector(
		new JsonInspectorConfig().setInputStream( new ByteArrayInputStream( jsonSchema.getBytes() ))));
	metawidget.addInspectionResultProcessor(
		new TypeMappingInspectionResultProcessor&lt;SwtMetawidget&gt;(
			new JsonSchemaTypeMappingProcessorConfig() ));
	metawidget.setInspectionPath( "personObject" );

	// Shell

	shell.setVisible( true );
	shell.open();

	while ( !shell.isDisposed() ) {
		if ( !display.readAndDispatch() ) {
			display.sleep();
		}
	}

	display.dispose();
}</programlisting>
				
			</section>
			
			<section id="section-inspectors-javascript-jsonschema">
				<title>JsonSchemaInspector (JavaScript version)</title>
				
				<para>				
					Inspects JSON Schemas for their properties. Because Metawidget <emphasis>already</emphasis>
					uses JSON Schema internally as its inspection result format, this Inspector does not need
					to do much. However it adds support for JSON schemas that contain nested schemas. For example:
				</para>
				
				<programlisting language="xml">&lt;html&gt;
	&lt;head&gt;
		&lt;script src="angular.min.js"&gt;&lt;/script&gt;
		&lt;script src="metawidget-core.min.js"&gt;&lt;/script&gt;
		&lt;script src="metawidget-angular.min.js"&gt;&lt;/script&gt;
		&lt;script&gt;
			angular.module( 'myApp', [ 'metawidget' ] );

			function UserController( $scope ) {

			$scope.user = {};

			$scope.config = {
				inspector: new metawidget.inspector.JsonSchemaInspector( {
					properties: {
					   title: { type: 'string', enum: ['Mr', 'Mrs', 'Ms'] },
					   name: { type: 'string' },
					   email: { type: 'string', required: true },
					   birthday: { type: 'date' },
					   password: { type: 'string', masked: true },
					   address: {
							properties: {
							   street: { type: 'string' },
							   city: { type: 'string' },
							   postcode: { type: 'string' }
							}
					   },
					   notes: { type: 'string', large: true }
					}
				} )
			}
		}
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body ng-app="myApp" ng-controller="UserController"&gt;
		&lt;metawidget ng-model="user" config="config"/&gt;
	&lt;/body&gt;
&lt;/html&gt;</programlisting>

				<para>
					Furthermore, <classname>JsonSchemaInspector</classname> adds support for JSON Schemas that
					describe array items, through the standard <parameter>items</parameter> property. For example:
				</para>
				
				<programlisting language="xml">&lt;html&gt;
	&lt;head&gt;
		&lt;script src="metawidget-core.min.js"&gt;&lt;/script&gt;
		&lt;style&gt;
			#metawidget {
				border: 1px solid #cccccc;
				width: 250px;
				border-radius: 10px;
				padding: 10px;
				margin: 50px auto;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id="metawidget"/&gt;
		&lt;script type="text/javascript"&gt;
			var mw = new metawidget.Metawidget( document.getElementById( 'metawidget' ), {
				inspector: new metawidget.inspector.CompositeInspector( [
					new metawidget.inspector.PropertyTypeInspector(),
					new metawidget.inspector.JsonSchemaInspector( {
						properties: {
							family: {
								items: {
									properties: {
										id: {
											type: 'string',
											hidden: true
										},
										employer: {
											type: 'string'
										}
									}
								}
							}
						}
					} )
				] )
			} );
			mw.toInspect = {
				firstname: 'Homer',
				surname: 'Simpson',
				age: 36,
				family: [ {
					id: 0,
					firstname: 'Marge',
					surname: 'Simpson'
				}, {
					id: 1,
					firstname: 'Bart',
					surname: 'Simpson'
				} ]
			};
			mw.buildWidgets();
		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;</programlisting>

			</section>

			<section id="section-inspectors-javascript-propertytype">
				<title>PropertyTypeInspector (JavaScript version)</title>
				
				<para>
					The JavaScript <classname>PropertyTypeInspector</classname> is much simplified compared
					to its Java-counterpart. It inspects JavaScript objects for their property names and types.
				</para>
				
				<para>
					Before ES2015/ES6, ordering of property names within JavaScript objects was not guaranteed,
					although most browsers respected the original order that properties were defined in. ES2015
					does specify the order for <function>Object.getOwnPropertyNames</function>, and
					<classname>PropertyTypeInspector</classname> will use
					<function>Object.getOwnPropertyNames</function>, if available, to ensure predictable ordering
					on modern browsers.
				</para>

				<para>
					If you need a different order, or you need to support older browsers, including Internet
					Explorer, you may want to combine <classname>PropertyTypeInspector</classname> with a custom
					<classname>Inspector</classname> that imposes a defined ordering using
					<parameter>propertyOrder</parameter> attributes.
				</para>
			</section>
			
		</section>

		<section id="section-inspectors-annotation">
			<title>Annotation Inspectors</title>

			<para>
				Beyond the base issue of inspecting an object and its properties, a number of <classname>Inspector</classname>s are focused on
				third-party annotations. These annotation <classname>Inspector</classname>s all extend <classname>BaseObjectInspector</classname>,
				and so inherit its features, but in addition they inspect the following frameworks.
			</para>

			<section id="section-inspectors-beanvalidation">
				<title>BeanValidationInspector</title>
				
				<para>
					<classname>BeanValidationInspector</classname> inspects Bean Validation (JSR 303) annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Bean Validation Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>maximum-fractional-digits</parameter></td>
							<td><classname>@Digits(fraction=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-integer-digits</parameter></td>
							<td><classname>@Digits(integer=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><classname>@Size(max=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-value</parameter></td>
							<td><classname>@Max</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-length</parameter></td>
							<td><classname>@Size(min=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-value</parameter></td>
							<td><classname>@Min</classname></td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><classname>@NotNull</classname></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-faces">
				<title>FacesAnnotationInspector</title>
				
				<para>
					<classname>FacesAnnotationInspector</classname> inspects Java Server Faces-specific annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<parameter>currency-code</parameter>,
								<parameter>currency-symbol</parameter>, 
								<parameter>number-uses-grouping-separators</parameter>, 
								<parameter>minimum-integer-digits</parameter>, 
								<parameter>maximum-integer-digits</parameter>, 
								<parameter>minimum-fractional-digits</parameter>, 
								<parameter>maximum-fractional-digits</parameter>, 
								<parameter>locale</parameter>,
								<parameter>number-pattern</parameter> and
								<parameter>number-type</parameter>
							</td>
							<td>
								<classname>@UiFacesNumberConverter</classname> - annotates the field should use the standard JSF
								<classname>NumberConverter</classname>.
								<para>
									Note: the <classname>NumberConverter</classname> property <parameter>integerOnly</parameter> is not specified
									using this annotation, as it can be inferred from the property's type
								</para>
							</td>
						</tr>
						<tr>
							<td>
								<parameter>date-style</parameter>,
								<parameter>locale</parameter>, 
								<parameter>datetime-pattern</parameter>, 
								<parameter>time-style</parameter>, 
								<parameter>time-zone</parameter> and
								<parameter>datetime-type</parameter> 
							</td>
							<td><classname>@UiFacesDateTimeConverter</classname> - annotates the field should use the standard JSF
							<classname>DateTimeConverter</classname></td>
						</tr>
						<tr>
							<td><parameter>faces-ajax-event</parameter></td>
							<td>
								<classname>@UiFacesAjax</classname> - annotates the widget for this field should use AJAX in
								response to the given event
							</td>
						</tr>
						<tr>
							<td><parameter>faces-component</parameter></td>
							<td>
								<classname>@UiFacesComponent</classname> - annotates the field should be rendered using the
								given <parameter>component type</parameter> in the UI.
								<para>
									Use of this annotation does not bind the business class to the UI quite as tightly
									as it may appear, because JSF has a loosely coupled relationship between
									<parameter>&lt;component-type&gt;</parameter> and <parameter>&lt;component-class&gt;</parameter>, and
									a further loose coupling between <parameter>&lt;component&gt;</parameter> and <parameter>&lt;render-kit&gt;</parameter>,
									as defined in <filename>faces-config.xml</filename>
								</para>
							</td>
						</tr>
						<tr>
							<td><parameter>faces-converter</parameter></td>
							<td>
								<classname>UiFacesConverter</classname> - annotates the field should use the given JSF converter
								in the UI. This annotation uses the converter <emphasis>id</emphasis>, not its class. Alternatively, this
								annotation can be an EL expression that evaluates to a <classname>javax.faces.convert.Converter</classname> instance.
							</td>
						</tr>
						<tr>
							<td><parameter>faces-lookup</parameter></td>
							<td>
								<classname>@UiFacesLookup</classname> - annotates the value in the field should
								belong to the <classname>Collection</classname> returned by the given EL expression
							</td>
						</tr>
						<tr>
							<td><parameter>faces-suggest</parameter></td>
							<td>
								<classname>@UiFacesSuggest</classname> - annotates the value in the field should
								be 'suggested' (i.e. using a pop-up box) using the <classname>Collection</classname>
								returned by the given EL expression
							</td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-hibernatevalidator">
				<title>HibernateValidatorInspector</title>
				
				<para>
					<classname>HibernateValidatorInspector</classname> inspects Hibernate Validator annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Hibernate Validator Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>maximum-fractional-digits</parameter></td>
							<td><classname>@Digits(fractionalDigits=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-integer-digits</parameter></td>
							<td><classname>@Digits(integerDigits=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><classname>@Length(max=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-value</parameter></td>
							<td><classname>@Max</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-length</parameter></td>
							<td><classname>@Length(min=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-value</parameter></td>
							<td><classname>@Min</classname></td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><classname>@NotNull</classname> or <classname>@NotEmpty</classname></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-jackson">
				<title>JacksonInspector</title>
				
				<para>
					<classname>JacksonInspector</classname> inspects Jackson annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Jackson Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>hidden</parameter></td>
							<td>
								<classname>@JsonIgnore</classname>
							</td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-jaxb">
				<title>JaxbInspector</title>
				
				<para>
					<classname>JaxbInspector</classname> inspects Java API for XML Binding (JAXB) annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">JPA Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>hidden</parameter></td>
							<td>
								<classname>@XmlTransient</classname>
							</td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><classname>@XmlElement(required=true)</classname></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-jpa">
				<title>JpaInspector</title>
				
				<para>
					<classname>JpaInspector</classname> inspects Java Persistence API annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">JPA Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>hidden</parameter></td>
							<td>
								<classname>@Id</classname>, unless <classname>JpaInspectorConfig.setHideIds</classname> is false.
								<classname>@Version</classname>, unless <classname>JpaInspectorConfig.setHideVersions</classname> is false.
								<classname>@Transient</classname>, unless <classname>JpaInspectorConfig.setHideTransients</classname> is false.
							</td>
						</tr>
						<tr>
							<td><parameter>large</parameter></td>
							<td><classname>@Lob</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><classname>@Column(length=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><classname>@Column(nullable=false)</classname> or <classname>@ManyToOne(optional=false)</classname></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-metawidgetannotation">
				<title>MetawidgetAnnotationInspector</title>
				
				<para>
					As much as possible, Metawidget tries to inspect metadata from existing sources, without
					introducing new concepts. Where that is not sufficient, <classname>MetawidgetAnnotationInspector</classname> adds
					a handful of annotations:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Metawidget Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>(any)</td>
							<td><classname>@UiAttributes</classname> and <classname>@UiAttribute</classname> - a 'catch all' for denoting arbitrary UI metadata</td>
						</tr>
						<tr>
							<td><parameter>action</parameter></td>
							<td><classname>@UiAction</classname></td>
						</tr>
						<tr>
							<td><parameter>comes-after</parameter></td>
							<td><classname>@UiComesAfter</classname></td>
						</tr>
						<tr>
							<td><parameter>dont-expand</parameter></td>
							<td>
								<classname>@UiDontExpand</classname> - denotes a value should not be inspected and expanded into sub-widgets. This
								can be useful if, say, you have a read-only property and just want to display its top-level <function>toString()</function>
								rather than all its child properties
							</td>
						</tr>
						<tr>
							<td><parameter>hidden</parameter></td>
							<td><classname>@UiHidden</classname> - denotes a value should be hidden in the UI. The value may
								still be rendered on the client, depending on the Metawidget (i.e. for Web clients,
								may use a HTML hidden field)
							</td>
						</tr>
						<tr>
							<td><parameter>label</parameter></td>
							<td><classname>@UiLabel</classname> - denotes the label to use in the UI. Can be a resource
								key if the UI is using resource bundles, or
								an EL expression if the UI has an expression language (i.e. JSF)
							</td>
						</tr>
						<tr>
							<td><parameter>large</parameter></td>
							<td><classname>@UiLarge</classname> - denotes the field should be 'large' in the UI (i.e. a multi-line textbox)</td>
						</tr>
						<tr>
							<td><parameter>lookup</parameter></td>
							<td><classname>@UiLookup</classname> - denotes the value in the field should belong to the given set of Strings</td>
						</tr>
						<tr>
							<td><parameter>masked</parameter></td>
							<td><classname>@UiMasked</classname> - denotes a value should be masked in the UI (e.g. a password field)</td>
						</tr>
						<tr>
							<td><parameter>read-only</parameter></td>
							<td><classname>@UiReadOnly</classname> - denotes a value should be read-only in the UI</td>
						</tr>
						<tr>
							<td><parameter>section</parameter></td>
							<td>
								<classname>@UiSection</classname> - denotes the start of a logical grouping in the UI.
								Subsequent properties are assumed
								to belong to the same section until a different section heading is encountered. Sections
								can be cancelled using a section heading with an empty String. Sections can be nested
								by specifying an array of section names.								
							</td>
						</tr>
						<tr>
							<td><parameter>wide</parameter></td>
							<td>
								<classname>@UiWide</classname> - denotes the field should be 'wide' in the UI, spanning all columns in a multi-column layout.
 								'Wide' is different to 'large', because 'large' implies a data size (i.e. BLOB or CLOB) whereas 'wide' refers purely to spanning
 								columns. Generally all 'large' fields are implicitly 'wide', but not all 'wide' fields are 'large'. For example, you may want
 								a normal text field (not a text area) to span all columns.
 							</td>
						</tr>
					</tbody>
				</informaltable>

			</section>
			
			<section id="section-inspectors-oval">
				<title>OvalInspector</title>
				
				<para>
					<classname>OvalInspector</classname> inspects OVal annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">OVal Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><classname>@Length(max=...)</classname> or <classname>@MaxLength</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-value</parameter></td>
							<td><classname>@Max</classname> or <classname>@Range(max=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-length</parameter></td>
							<td><classname>@Length(min=...)</classname> or <classname>@MinLength</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-value</parameter></td>
							<td><classname>@Min</classname> or <classname>@Range(min=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><classname>@NotNull</classname> or <classname>@NotEmpty</classname> or <classname>@NotBlank</classname></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

		</section>

		<section id="section-inspectors-xml">
			<title>XML Inspectors</title>
			
			<para>
				Whilst we don't necessarily encourage the use of XML-based metadata, if you <emphasis>already</emphasis> have XML configuration
				files in your architecture Metawidget will take advantage of them. Equally, XML can be useful for declaring 'ad hoc' UI entities
				that do not map to any Java class, as well as for declaring UI-specific attributes for existing Java classes (i.e. if you prefer
				not to use annotations, or if you want to introduce additional 'virtual' properties).
			</para>

			<para>			
				Note when using XML-based metadata you should still try to avoid duplicating metadata that already exists in other parts of
				your application. For example, if you are also using <classname>PropertyTypeInspector</classname> in your
				<classname>CompositeInspector</classname> there is no need to duplicate the names and types of all properties.
			</para>
			
			<para>
				Once nice feature of XML is that ordering of child elements (such as <parameter>&lt;property&gt;</parameter>) is
				explicit, so XML-based <classname>Inspector</classname>s make great 'first inspectors' for use within <classname>CompositeInspector</classname> (e.g. you
				don't need to also use <classname>@UiComesAfter</classname>).
			</para>
			
			<section id="section-inspectors-basexml">
				<title>BaseXmlInspector</title>
				
				<para>
					<classname>BaseXmlInspector</classname>'s config class, <classname>BaseXmlInspectorConfig</classname>, uses a
					<function>setInputStream</function> method to specify the location of the XML. This allows a variety of options
					for sourcing the XML. For example:
				</para>

				<programlisting language="xml">&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml"
	config="XmlInspectorConfig"&gt;
	&lt;inputStream&gt;
		&lt;resource&gt;com/myapp/metawidget-metadata.xml&lt;/resource&gt;
	&lt;/inputStream&gt;
&lt;/xmlInspector&gt;</programlisting>					
				
				<para>
					And:
				</para>

				<programlisting language="xml">&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml"
	config="XmlInspectorConfig"&gt;
	&lt;inputStream&gt;
		&lt;url&gt;http://myserver.com/my-xml.xml&lt;/url&gt;
	&lt;/inputStream&gt;
&lt;/xmlInspector&gt;</programlisting>					

				<para>
					As well as specifying multiple files (which will all be merged and inspected as one):
				</para>

				<programlisting language="xml">&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml"
	config="XmlInspectorConfig"&gt;
	&lt;inputStreams&gt;
		&lt;array&gt;
			&lt;url&gt;http://myserver.com/my-xml-1.xml&lt;/url&gt;
			&lt;url&gt;http://myserver.com/my-xml-2.xml&lt;/url&gt;
		&lt;/array&gt;			
	&lt;/inputStreams&gt;
&lt;/xmlInspector&gt;</programlisting>					

				<para>
					This functionality is extended to all XML-based <classname>Inspector</classname>s.
				</para>
				
				<section id="section-inspectors-basexml-mixing-xml-object">
					<title>Mixing XML and Object-based Inspectors</title>
					
					<para>
						Several pieces of <classname>BaseXmlInspector</classname> functionality
						apply to mixing XML-based <classname>Inspector</classname>s (e.g. <classname>XmlInspector</classname>) and Object-based
						<classname>Inspector</classname>s
						(e.g. <classname>PropertyTypeInspector</classname>) in the same application (i.e. via <classname>CompositeInspector</classname>).
					</para>
					
					<para>
						First, you may encounter a problem whereby the Object-based
						<classname>Inspector</classname>s will always stop at <parameter>null</parameter> or recursive
						references, whereas the XML <classname>Inspector</classname>s (which have no knowledge of Object values) will continue.
						This can lead to the <classname>WidgetBuilder</classname>s constructing	a UI for a <parameter>null</parameter> Object, which may upset some
						<classname>WidgetProcessor</classname>s (e.g. <classname>BeansBindingProcessor</classname>). To resolve this, you can set
						<function>BaseXmlInspectorConfig.setRestrictAgainstObject</function>,
						whereby the XML-based <classname>Inspector</classname> will do a check for <parameter>null</parameter> or recursive
						references, and not return any XML. In addition, setting <parameter>restrictAgainstObject</parameter>
						allows the XML <classname>Inspector</classname> to traverse child relationships and infer their types
	 					using the Object. This saves having to explicitly specify those types and relationships in the XML.
					</para>
					
					<para>
						Second, by default you need to explicitly specify any inheritance relationships between types in the XML, because the XML
						has no knowledge of your Java classes. This includes the names of any proxied classes. If this becomes laborious, you can set
						<function>BaseXmlInspectorConfig.setInferInheritanceHierarchy</function> to infer the relationships automatically
						from your Java classes. If you are using <function>setRestrictAgainstObject</function>, <function>setInferInheritanceHierarchy</function>
						is implied.
					</para>
					
					<para>
 						Third, it is important the properties defined by the XML and the ones defined by the
						Java classes stay in sync. To enforce this, you can set
						<function>BaseXmlInspectorConfig.setValidateAgainstClasses</function>.					
					</para>
				</section>
				
 			</section>

			<section id="section-inspectors-commonsvalidator">
				<title>CommonsValidatorInspector</title>
				
				<para>
					<classname>CommonsValidatorInspector</classname> inspects Apache Commons Validator <filename>validation.xml</filename>
					files. It returns the following attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Validator XML</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><parameter>&lt;field depends="maxlength" /&gt;&lt;var&gt;&lt;var-name&gt;maxlength&lt;/var-name&gt;...</parameter></td>
						</tr>
						<tr>
							<td><parameter>maximum-value</parameter></td>
							<td><parameter>&lt;field depends="intRange" /&gt;&lt;var&gt;&lt;var-name&gt;max&lt;/var-name&gt;...</parameter> (or <parameter>floatRange</parameter> or <parameter>doubleRange</parameter>)</td>
						</tr>
						<tr>
							<td><parameter>minimum-length</parameter></td>
							<td><parameter>&lt;field depends="minlength" /&gt;&lt;var&gt;&lt;var-name&gt;minlength&lt;/var-name&gt;...</parameter></td>
						</tr>
						<tr>
							<td><parameter>minimum-value</parameter></td>
							<td><parameter>&lt;field depends="intRange" /&gt;&lt;var&gt;&lt;var-name&gt;min&lt;/var-name&gt;...</parameter> (or <parameter>floatRange</parameter> or <parameter>doubleRange</parameter>)</td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><parameter>&lt;field depends="required" /&gt;</parameter></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-hibernate">
				<title>HibernateInspector</title>
				
				<para>
					<classname>HibernateInspector</classname> inspects Hibernate <filename>hibernate.cfg.xml</filename> and
					<filename>mapping.hbm.xml</filename> files. For the former, it iterates over <parameter>&lt;session-factory&gt;</parameter>'s
					<parameter>&lt;mapping&gt;</parameter> elements and inspects all mapping files.
					It returns the following attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Hibernate XML</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>hidden</parameter></td>
							<td><parameter>&lt;id /&gt;</parameter></td>
						</tr>
						<tr>
							<td><parameter>large</parameter></td>
							<td><parameter>&lt;property type="clob" /&gt;</parameter></td>
						</tr>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><parameter>&lt;property length="..." /&gt;</parameter></td>
						</tr>
						<tr>
							<td><parameter>parameterized-type</parameter></td>
							<td><parameter>&lt;bag type="..." /&gt;</parameter> or <parameter>&lt;list type="..." /&gt;</parameter> or <parameter>&lt;set type="..." /&gt;</parameter></td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><parameter>&lt;property not-null="true" /&gt;</parameter></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-pageflow">
				<title>PageflowInspector</title>
				
				<para>
					<classname>PageflowInspector</classname> inspects JBoss jBPM pageflow files 
					looking for <parameter>page</parameter> nodes and their associated <parameter>transition</parameter>s to
					be used as actions. For example, this <filename>pageflow.jpdl.xml</filename> file...
				</para>
				
				<programlisting language="xml">&lt;page name="confirm"&gt;
	&lt;transition name="purchase" to="complete" /&gt;
	&lt;transition name="cancel" to="cancel" /&gt;
&lt;/page&gt;</programlisting>
				
				<para>
					...would return <parameter>purchase</parameter> and <parameter>cancel</parameter> as available
					actions for the <parameter>confirm</parameter> page. For an example of <classname>PageflowInspector</classname>
					in use, see <xref linkend="section-introduction-part3-jbpm"/>.
				</para>
			</section>
			
			<section id="section-inspectors-seam">
				<title>SeamInspector</title>
				
				<para>
					<classname>SeamInspector</classname> inspects Seam XML files for useful metadata. Specifically:
				</para>
				
				<itemizedlist>
					<listitem>
						<para>
							Delegates <parameter>jbpm:pageflow-definitions</parameter> elements from <filename>components.xml</filename> to <classname>PageflowInspector</classname>.
						</para>
					</listitem>
				</itemizedlist>
			</section>

			<section id="section-inspectors-xml-xmlinspector">
				<title>XmlInspector</title>
				
				<para>
					<classname>XmlInspector</classname> inspects <filename>inspection-result-1.0.xsd</filename>-compliant files (such as
					<filename>metawidget-metadata.xml</filename>).
				</para>
				
				<para>
					<classname>XmlInspector</classname> is a very simple Inspector: it takes as its input XML in the same format that
					<classname>Inspector</classname>s usually output. It can be useful for declaring 'ad hoc' UI entities that do not map to
					any Java class, as well as for declaring UI-specific attributes for existing Java classes (ie. if
					you prefer not to use annotations, or if you want to introduce additional 'virtual' properties). Some attributes
					accept multiple values, such as <parameter>lookup</parameter>. These can be supplied as a comma-separated
					string. The values will be trimmed for whitespace. If the values themselves contain commas, they can be escaped with the
					<parameter>\</parameter> character.
				</para>
				
				<para>
					Note when using <classname>XmlInspector</classname> you should still try to avoid duplicating UI metadata
					that already exists in other parts of your application. For example, if you are also using
					<classname>PropertyTypeInspector</classname> in your <classname>CompositeInspector</classname> there is no need to
					duplicate the names and types of properties. Also, if you are using
					<classname>PropertyTypeInspector</classname> and <classname>XmlInspector</classname> together, please read the
					documentation for <parameter>restrictAgainstObject</parameter>.
				</para>
				
				<para>
					<classname>XmlInspector</classname> does add some niceties beyond <filename>inspection-result-1.0.xsd</filename>.
					It supports an <parameter>extends</parameter> attribute to allow one <parameter>entity</parameter> to inherit from
					another. It also supports nested entities, for example:
				</para>
	
				<programlisting language="xml">&lt;entity type="Person"&gt;
   &lt;property name="surname"/&gt;
   &lt;property name="address"&gt;
      &lt;property name="street"/&gt;
      &lt;property name="postcode"/&gt;
   &lt;/property&gt;
&lt;/entity&gt;</programlisting>
				
			</section>

			<section id="section-inspectors-xml-xsdinspector">
				<title>XmlSchemaInspector</title>
				
				<para>
					<classname>XmlSchemaInspector</classname> inspects XML Schema (XSD) files. If used for a
					Java environment, consider using in conjunction with <classname>XmlSchemaToJavaTypeMappingProcessor</classname>.
					For returning results to JavaScript environments, consider <classname>JavaToJavaScriptTypeMappingProcessor</classname>
					and <classname>XmlUtils.elementToJson</classname>.				
				</para>
				
			</section>

			<section id="section-inspectors-xml-wsdlinspector">
				<title>WsdlInspector</title>
				
				<para>
					<classname>WsdlInspector</classname> inspects Web Services Description Language (WSDL) files. It extracts
					the XML Schema from the <parameter>&lt;schema&gt;</parameter> element of the WSDL and parses it for
					useful metadata.
				</para>
				
				<para>
					If <classname>WsdlInspector</classname> is used for a Java environment, consider using it
					in conjunction with <classname>XmlSchemaToJavaTypeMappingProcessor</classname>. For returning results to JavaScript
					environments, consider <classname>JavaToJavaScriptTypeMappingProcessor</classname> and <classname>XmlUtils.elementToJson</classname>.				
				</para>
				
			</section>

		</section>

	</chapter>
